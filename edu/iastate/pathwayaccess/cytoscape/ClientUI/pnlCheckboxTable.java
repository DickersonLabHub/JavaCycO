/*
 * pnlCheckboxTable.java
 *
 * Created on Apr 7, 2011, 1:36:37 PM
 */

package edu.iastate.pathwayaccess.cytoscape.ClientUI;

import java.lang.Boolean;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.table.AbstractTableModel;

/**
 * Panel with a table containing checkboxes in the first column, navigation for
 * pages of contents of the table, and a select all checkbox.
 * @author Greg Hazen
 */
public class pnlCheckboxTable extends javax.swing.JPanel {

    /**
     * Stores the maximum number of rows displayed at one time.
     */
    private int MAX_ROWS_DISPLAYED = 25;
    /**
     * Stores the model for the table
     */
    private PathwayTableModel tableModel = null;

    /**
     * Creates new form pnlCheckboxTable and sets the max number of rows to
     * display in the table at one time to the given number of rows. The table
     * can have multiple pages of data and is navigated via button above the
     * panel.
     * @param maxRows The max number of rows to display in the table at one time
     * @param columnNames Names of each column in the table including the
     * column for checkboxes. If null, column names are set to the default
     * of [0] "Check" [1] "Items"
     * @param tableData Data to fill the table with organized by row first
     * then column (cellData[row][column]). For example, the third cell in
     * the fifth row is cellData[5][3]. The first column of data is the
     * determines if the checkbox for that row is initially checked. To set
     * the value of the first column, use new Boolean(true/false). All items
     * will be displayed in the table as the string returned by a call to
     * each object's toString(). Null data is replaced with "" or false if
     * in the first column of data. Data in columns beyond the length of the
     * number of given column names will be ignored.
     */
    public pnlCheckboxTable(int maxRows/*, String[] columnNames, Object[][] tableData*/) {
        MAX_ROWS_DISPLAYED = maxRows;
        initComponents();
        //setData(columnNames, tableData);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
        // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
        private void initComponents() {

                scrPathwaysTable = new javax.swing.JScrollPane();
                tblPathways = new javax.swing.JTable();
                chkSelectAll = new javax.swing.JCheckBox();
                btnPrevResultsPage = new javax.swing.JButton();
                lblNumResultsDisplayed = new javax.swing.JLabel();
                btnNextResultsPage = new javax.swing.JButton();

                setMinimumSize(new java.awt.Dimension(427, 129));

                tblPathways.setModel(new javax.swing.table.DefaultTableModel());
                tblPathways.setToolTipText("Select a pathway to open as a CyNetwork");
                tblPathways.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
                scrPathwaysTable.setViewportView(tblPathways);

                chkSelectAll.setText("Select All");
                chkSelectAll.addMouseListener(new java.awt.event.MouseAdapter() {
                        public void mouseClicked(java.awt.event.MouseEvent evt) {
                                chkSelectAllMouseClicked(evt);
                        }
                });

                btnPrevResultsPage.setText("Prev " + MAX_ROWS_DISPLAYED);
                btnPrevResultsPage.setToolTipText("Select to go to the previous results page");
                btnPrevResultsPage.setEnabled(false);
                btnPrevResultsPage.addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                                btnPrevResultsPageActionPerformed(evt);
                        }
                });

                lblNumResultsDisplayed.setText("Results ### to ###/###");

                btnNextResultsPage.setText("Next " + MAX_ROWS_DISPLAYED);
                btnNextResultsPage.setToolTipText("Select to go to the next results page");
                btnNextResultsPage.setEnabled(false);
                btnNextResultsPage.addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                                btnNextResultsPageActionPerformed(evt);
                        }
                });

                javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
                this.setLayout(layout);
                layout.setHorizontalGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(lblNumResultsDisplayed)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnPrevResultsPage)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnNextResultsPage)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 10, Short.MAX_VALUE)
                                .addComponent(chkSelectAll))
                        .addComponent(scrPathwaysTable, javax.swing.GroupLayout.DEFAULT_SIZE, 427, Short.MAX_VALUE)
                );
                layout.setVerticalGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(btnPrevResultsPage, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(btnNextResultsPage, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(chkSelectAll)
                                        .addComponent(lblNumResultsDisplayed))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(scrPathwaysTable, javax.swing.GroupLayout.DEFAULT_SIZE, 104, Short.MAX_VALUE))
                );
        }// </editor-fold>//GEN-END:initComponents

    /**
     * We must create our own table model in order to allow check boxes to work
     */
    private class PathwayTableModel extends AbstractTableModel {
        /**
         * Names of each column
         */
        private String[] columnNames = {"Check",
                                        "Items"};
        /**
         * Data currently being displayed in the table
         */
        private Object[][] curPageData = null;
        /**
         * All data in table, including data not displayed on current page
         */
        private Object[][] allData = null;
        /**
         * Stores data from the rows that have been selected
         */
        private ArrayList<Object[]> selectedRows = new ArrayList<Object[]>();

        /**
         * Creates/Stores all the data for the table
         * @param columnNames Names of each column in the table including the
         * column for checkboxes. If null, column names are set to the default
         * of [0] "Check" [1] "Items"
         * @param cellData Data to fill the table with organized by row first
         * then column (cellData[row][column]). For example, the third cell in
         * the fifth row is cellData[5][3]. The first column of data is the
         * determines if the checkbox for that row is initially checked. To set
         * the value of the first column, use new Boolean(true/false). All items
         * will be displayed in the table as the string returned by a call to
         * each object's toString(). Null data is replaced with "" or false if
         * in the first column of data. Data in columns beyond the length of the
         * number of given column names will be ignored.
         */
        public PathwayTableModel(String[] columnNames, Object[][] cellData)
        {
            if(cellData == null)
                throw new NullPointerException("Null data is not allowed");
            //Get the names of the columns
            if(columnNames != null) this.columnNames = columnNames;
            //Only copy columns within number of column names
            allData = new Object[cellData.length][columnNames.length];
            for(int row = 0; row < cellData.length; row++)
            {
                for(int col = 0; col < columnNames.length; col++)
                {
                    //Replace null with "" or false if in the first column
                    if(cellData[row][col] == null)
                        if(row == 0) cellData[row][col] = new Boolean(false);
                        else cellData[row][col] = "";
                    allData[row][col] = cellData[row][col];
                }
            }
            //Copy over the data for the first page
            int numData = cellData.length;
            int numRows = numData;
            if(numData > MAX_ROWS_DISPLAYED)
                numRows = MAX_ROWS_DISPLAYED;
            curPageData = new Object[numRows][columnNames.length];
            for(int row = 0; row < numRows; row++)
                curPageData[row] = allData[row];
            curPageFirstRow = 0;
        }
        /**
         * Returns the rows of data that have been selected (not including data
         * beyond the width of the number of columns names nor the checkbox
         * values).
         * @return The rows of data that have been selected
         */
        public Object[][] getSelectedRows()
        {
            //return (Object[][])selectedRows.toArray();
            Iterator<Object[]> itr = selectedRows.iterator();
            Object[][] ret = new Object[selectedRows.size()][columnNames.length - 1];
            for(int row = 0; itr.hasNext(); row++) 
            {
                for(int col = 1; col < columnNames.length; col++)
                    ret[row][col-1] = itr.next()[col];
            }
            return ret;
        }
        /**
         * Stores the first row currently displayed in the table
         */
        private int curPageFirstRow = 0;
        /**
         * If more pages of data in the table are available, goes to the next page.
         * @return The index of the first result on the current page with the
         * index count starting at zero (i.e. if there are 25 results per page and
         * it's the second page, the given index would be 25). There is no next
         * page, -1 is returned.
         */
        public int nextPage()
        {
            if(!hasNextPage()) return -1;
            curPageFirstRow += MAX_ROWS_DISPLAYED;
            int pos = curPageFirstRow;
            int posMax = MAX_ROWS_DISPLAYED;
            int totalRows = getTotalRowCount();
            //If on the last page, check end position and resize table accordingly
            if(curPageFirstRow < totalRows && (curPageFirstRow + MAX_ROWS_DISPLAYED) > totalRows)
            {
                posMax = totalRows - curPageFirstRow;
                curPageData = new Object[posMax][3];
            }
            //Copy new results to table
            for(int row = 0; row < posMax; row++, pos++)
                curPageData[row] = allData[pos];
            fireTableDataChanged();
            return curPageFirstRow;
        }
        /**
         * Returns true if a page following the current page of data is available,
         * otherwise false.
         * @return True if a page following the current page of data is available,
         * otherwise false.
         */
        public boolean hasNextPage()
        {
            if((curPageFirstRow + MAX_ROWS_DISPLAYED) > allData.length)
                return false;
            return true;
        }
        /**
         * If previous pages of data in the table are available, goes to the previous page.
         * @return The index of the first result on the current page with the
         * index count starting at zero (i.e. if there are 25 results per page and
         * it's the second page, the given index would be 25). If there is no
         * previous page, -1 is returned.
         */
        public int previousPage()
        {
            if(!hasPreviousPage()) return -1;
            //If on the last page, resize table back to full size
            int totalRows = getTotalRowCount();
            if(curPageFirstRow < totalRows && (curPageFirstRow + MAX_ROWS_DISPLAYED) > totalRows)
            {
                curPageData = new Object[MAX_ROWS_DISPLAYED][3];
            }
            curPageFirstRow -= MAX_ROWS_DISPLAYED;
            int pos = curPageFirstRow;
            //Copy new results to table
            for(int row = 0; row < MAX_ROWS_DISPLAYED; row++, pos++)
                curPageData[row] = allData[pos];
            fireTableDataChanged();
            return curPageFirstRow;
        }
        /**
         * Returns true if a page prior to the current page of data is available,
         * otherwise false.
         * @return True if a page prior to the current page of data is available,
         * otherwise false.
         */
        public boolean hasPreviousPage()
        {
            if(curPageFirstRow < MAX_ROWS_DISPLAYED)
                return false;
            return true;
        }
        /**
         * Returns the number of rows currently showing
         * @return The number of rows currently showing
         */
        public int getRowCount() {
            return curPageData.length;
        }
        /**
         * Returns the total number of rows of results available
         * @return The total number of rows available
         */
        public int getTotalRowCount() {
            return allData.length;
        }

        /**
         * Returns the number of columns
         * @return The number of columns
         */
        public int getColumnCount() {
            return columnNames.length;
        }
        /**
         * Returns the name of the given column
         * @param col Column
         * @return The name of the given column
         */
        @Override
        public String getColumnName(int col) {
            if(col >= columnNames.length)
                return "";
            return columnNames[col];
        }
        /**
         * This returns the value at the given row and column
         * @param rowIndex Row
         * @param columnIndex Column
         * @return Value at the given row and column. Null if it's not a valid
         *         index.
         */
        public Object getValueAt(int rowIndex, int columnIndex) {
            if(rowIndex < curPageData.length && columnIndex < columnNames.length)
                return curPageData[rowIndex][columnIndex];
            return null;
        }
        /*
         * Implemented to allow the checkboxes to change value. Also, updates
         * the list of networks selectedRows to create and enables/disables the
         * network create button according to whether there are any pathways
         * selectedRows. Keeps a list of unique IDs of pathways selected to
         * create.
         */
        @Override
        public void setValueAt(Object value, int rowIndex, int columnIndex) {
            if(isCellEditable(rowIndex, columnIndex))
            {
                //Set the new value and update listeners of the change
                curPageData[rowIndex][columnIndex] = value;
                fireTableCellUpdated(rowIndex, columnIndex);

                //Update list of selected networks to create
                Object[] selRow = curPageData[rowIndex];
                if((Boolean)value == false)
                {
                    //Remove the row index from the list of selected rows
                    //if(selectedRows.contains((Integer)rowIndex))
                    //    selectedRows.remove((Integer)rowIndex);
                    //Remove the network from the list of selected networks
                    if(selectedRows.contains(selRow))
                        selectedRows.remove(selRow);
                }
                else
                {
                    //Add the row index from the list of selected rows
                    //if(!selectedRows.contains((Integer)rowIndex))
                    //    selectedRows.add((Integer)rowIndex);
                    //Add the network to the list of selected networks
                    if(!selectedRows.contains(selRow))
                        selectedRows.add(selRow);
                }
            }
        }
        /*
         * This is neccessary to let the checkbox work; without this it was only
         * display the boolean. This returns the class of the objects stored
         * under the given column.
         */
        @Override
        public Class getColumnClass(int col) {
            if(col >= columnNames.length)
                return Object.class;
            Object obj = getValueAt(0, col);
            if(obj == null)
                return Object.class;
            return obj.getClass();
        }
        /**
         * Returns whether the given row and column is editable
         * @param row Row
         * @param col Column
         * @return Whether the given row and column is editable. Returns true
         *         only for the checkbox.
         */
        @Override
        public boolean isCellEditable(int row, int col) {
            if(col == 0 && row < curPageData.length)
                return true;
            return false;
        }
    }

    private void chkSelectAllMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_chkSelectAllMouseClicked
        //Get current state
        boolean selectAll = chkSelectAll.isSelected();
        //Set all checkboxes accordingly
        for(int row = 0; row < tblPathways.getModel().getRowCount(); row++)
            tblPathways.setValueAt(selectAll, row, 0);
}//GEN-LAST:event_chkSelectAllMouseClicked

    private void btnPrevResultsPageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPrevResultsPageActionPerformed
        enablePageComponents(tableModel.previousPage());
}//GEN-LAST:event_btnPrevResultsPageActionPerformed

    private void btnNextResultsPageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNextResultsPageActionPerformed
        enablePageComponents(tableModel.nextPage());
}//GEN-LAST:event_btnNextResultsPageActionPerformed

    /**
     * Enables/Disables the page buttons according to the pages available and
     * updates the label showing the current results numbers currently in the table.
     * @param The index within all results available of the first result showing.
     * The index starts at zero (i.e. if there are 25 results per page and it's
     * the second page, the given index would be 25).
     */
    private void enablePageComponents(int firstResultIndex)
    {
        //Enable/Disable Next/Previous Page button
        btnPrevResultsPage.setEnabled(tableModel.hasPreviousPage());
        btnNextResultsPage.setEnabled(tableModel.hasNextPage());
        //Update results numbers currently displayed in the table
        int first = firstResultIndex + 1;
        int totalNumResults = tableModel.getTotalRowCount();
        int last = firstResultIndex + tableModel.getRowCount();
        //If no results, set numbers to all zeros
        if(totalNumResults == 0)
        {
            lblNumResultsDisplayed.setText("Results 0 to 0/0");
            return;
        }
        //If on last page, display the total # of results instead
        if(first < totalNumResults && (first + MAX_ROWS_DISPLAYED) > totalNumResults)
                last = totalNumResults;
        lblNumResultsDisplayed.setText(
                "Results " + first + " to " + last + "/" + totalNumResults);
    }

    /**
     * Sets the table data to the given data and column names
     * @param columnNames Names of each column in the table including the
     * column for checkboxes. If null, column names are set to the default
     * of [0] "Check" [1] "Items"
     * @param tableData Data to fill the table with organized by row first
     * then column (cellData[row][column]). For example, the third cell in
     * the fifth row is cellData[5][3]. The first column of data is the
     * determines if the checkbox for that row is initially checked. To set
     * the value of the first column, use new Boolean(true/false). All items
     * will be displayed in the table as the string returned by a call to
     * each object's toString(). Null data is replaced with "" or false if
     * in the first column of data. Data in columns beyond the length of the
     * number of given column names will be ignored.
     */
    public void setData(String[] columnNames, Object[][] tableData)
    {
        if(tableData == null)
            throw new NullPointerException("Null Array");
        //Create the network results table
        tableModel = new PathwayTableModel(columnNames, tableData);
        tblPathways.setModel(tableModel);
        //Update page navigation components
        enablePageComponents(0);
    }

    /**
     * Returns the rows of data that have been selected (not including data
     * beyond the width of the number of columns names nor the checkbox
     * values).
     * @return The rows of data that have been selected
     */
    public Object[][] getSelectedRows()
    {
        return tableModel.getSelectedRows();
    }

        // Variables declaration - do not modify//GEN-BEGIN:variables
        private javax.swing.JButton btnNextResultsPage;
        private javax.swing.JButton btnPrevResultsPage;
        private javax.swing.JCheckBox chkSelectAll;
        private javax.swing.JLabel lblNumResultsDisplayed;
        private javax.swing.JScrollPane scrPathwaysTable;
        private javax.swing.JTable tblPathways;
        // End of variables declaration//GEN-END:variables

}
